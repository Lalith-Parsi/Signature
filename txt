# -*- coding: utf-8 -*-
"""
Michigan e-Filing automation ‚Äî precise behavior:
- Iterate rows top-to-bottom, page-by-page
- If Filing Type ‚àà {Consent Judgement, Proposed Judgment/Order} AND
  Status ‚àà {Accepted, Filed, Rejected, Complete, Completed}:
    -> ALWAYS log CSV: case number | filing type | status
    -> IF status is Filed: click row (same tab) -> Status Updates -> Filed Stamped Copy
       -> wait for download -> rename -> scroll back to table
- After last row on page: click Next (#historyTable_next) and continue until disabled
- No browser back, no reload, no new tabs. Slow, steady sleeps everywhere.
"""

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException, StaleElementReferenceException, ElementClickInterceptedException
)
import time, os, glob, csv, re
from datetime import datetime


class MichiganAutomation:
    BASE_HISTORY_URL = "https://mifile.courts.michigan.gov/filings/myHistory"

    def __init__(self, download_path=None):
        self.download_path = download_path or os.path.join(
            os.getcwd(), "downloads", datetime.now().strftime("%Y%m%d_%H%M%S")
        )
        self.total_downloads = 0
        self.processed_pages = 0
        self.spreadsheet_path = None
        self.driver = None
        self.wait = None

        # ---- Pacing (tune here) ----
        self.t_row   = 1.0   # pause after each row processed/checked
        self.t_short = 0.8   # short UI pause
        self.t_med   = 1.4   # general step pause
        self.t_long  = 2.0   # navigation / redraw pause
        self.t_dlchk = 1.0   # download settle check

        # Resolved per page
        self.col_case = None
        self.col_type = None
        self.col_status = None

        self._setup_browser()

    # ---------------------------
    # Setup & helpers
    # ---------------------------
    def _setup_browser(self):
        print("üöÄ Starting Chrome‚Ä¶")
        options = Options()
        os.makedirs(self.download_path, exist_ok=True)
        options.add_experimental_option("prefs", {
            "download.default_directory": self.download_path,
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True,
            "plugins.always_open_pdf_externally": True,  # force download, no viewer
        })
        options.add_argument("--start-maximized")
        options.add_argument("--disable-extensions")
        options.add_argument("--disable-popup-blocking")
        options.add_argument("--disable-infobars")
        # options.add_argument("--headless=new")  # optional
        self.driver = webdriver.Chrome(options=options)
        self.wait = WebDriverWait(self.driver, 30)
        self._init_csv()
        print(f"‚úÖ Chrome ready. Downloads ‚Üí {self.download_path}")

    def _init_csv(self):
        self.spreadsheet_path = os.path.join(self.download_path, "status_notes.csv")
        if not os.path.exists(self.spreadsheet_path):
            with open(self.spreadsheet_path, "w", newline="", encoding="utf-8") as f:
                csv.writer(f).writerow(["case number", "filing type", "status"])
        print(f"üìù CSV ‚Üí {self.spreadsheet_path}")

    def _sleep(self, sec):
        time.sleep(sec)

    def _norm(self, s):
        s = (s or "").strip()
        s = re.sub(r"\s+", " ", s)
        return s.lower()

    def _safe_fragment(self, s):
        s = (s or "").strip().replace("/", "_")
        s = re.sub(r"[^A-Za-z0-9._-]+", "_", s)
        s = re.sub(r"_+", "_", s).strip("_")
        return s

    def _canonical_type_for_csv(self, raw):
        """Return the CSV-facing canonical label with spaces/slash preserved."""
        n = self._norm(raw)
        if "consent" in n and "judg" in n:
            # Use the user's spelling in CSV
            return "Consent Judgement"
        if "proposed" in n and "judg" in n:
            return "Proposed Judgment/Order"
        return raw or "Filing"

    def _canonical_type_for_filename(self, raw):
        """Return a tight filename-safe label."""
        label = self._canonical_type_for_csv(raw)
        # Replace slash in filename flavor
        label = label.replace(" / ", " ").replace("/", "_")
        return self._safe_fragment(label)

    def _log_csv(self, case_number, filing_type_label, status_text):
        with open(self.spreadsheet_path, "a", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow([case_number, filing_type_label, status_text])
        print(f"  üßæ CSV ‚Üí {case_number} | {filing_type_label} | {status_text}")
        self._sleep(self.t_short)

    # ---------------------------
    # Modals
    # ---------------------------
    def _click_any_ok(self):
        try:
            selectors = [
                "//*[self::button or self::input][contains(translate(normalize-space(.),'ok','OK'),'OK')]",
                "//div[contains(@class,'modal') or contains(@class,'dialog')]//*[self::button or self::input][contains(translate(normalize-space(.),'ok','OK'),'OK')]",
                "//div[@class='generic-modal']//button",
                "/html/body/div[1]/div/div/generic-modal//button",
            ]
            for xp in selectors:
                for b in self.driver.find_elements(By.XPATH, xp):
                    if b.is_displayed() and b.is_enabled():
                        try:
                            b.click()
                        except ElementClickInterceptedException:
                            self.driver.execute_script("arguments[0].click();", b)
                        print("‚úÖ Dismissed OK")
                        self._sleep(self.t_short)
                        return True
            return False
        except Exception:
            return False

    # ---------------------------
    # Login & search
    # ---------------------------
    def login(self, email=None, password=None):
        try:
            print("\nüîê Login‚Ä¶")
            self.driver.get(self.BASE_HISTORY_URL)
            self._sleep(self.t_med)
            self._click_any_ok()
            self._sleep(self.t_short)

            email = os.getenv("MI_EMAIL") or email or "Michigan@mandarichlaw.com"
            password = os.getenv("MI_PASSWORD") or password or "MiTeam1!"

            email_field = self.wait.until(EC.presence_of_element_located((By.XPATH, "//input[@type='email']")))
            email_field.clear(); email_field.send_keys(email); self._sleep(self.t_short)
            pwd_field = self.wait.until(EC.presence_of_element_located((By.XPATH, "//input[@type='password']")))
            pwd_field.clear(); pwd_field.send_keys(password); self._sleep(self.t_short)

            ci, co = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz"
            login_btn = self.wait.until(EC.element_to_be_clickable((
                By.XPATH, f"//button[contains(translate(normalize-space(.),'{ci}','{co}'),'log in')] | //input[@type='submit']"
            )))
            login_btn.click(); self._sleep(self.t_long)
            self._click_any_ok(); self._sleep(self.t_short)
            print("‚úÖ Logged in.")
            return True
        except Exception as e:
            print("‚ùå Login failed:", e)
            return False

    def set_date_and_search(self, start_date="07/01/2025"):
        try:
            print("\nüìÖ Set start date & Search‚Ä¶")
            date_field = self.wait.until(EC.element_to_be_clickable((By.ID, "StartDateFilingHistoryPane")))
            date_field.clear(); date_field.send_keys(start_date); date_field.send_keys("\n"); self._sleep(self.t_med)

            search_button = self.wait.until(EC.element_to_be_clickable((
                By.XPATH, "//button[contains(@class,'flatButton') and contains(@ng-click,'getHistory')]"
            )))
            self.driver.execute_script("arguments[0].click();", search_button)
            print("‚è≥ Waiting for results‚Ä¶")
            self.wait.until(lambda d: len(d.find_elements(By.CSS_SELECTOR, "table tbody tr")) > 0)
            self._sleep(self.t_long)
            print("‚úÖ Results loaded.")
            return True
        except Exception as e:
            print("‚ùå Search failed:", e)
            return False

    # ---------------------------
    # Table & columns
    # ---------------------------
    def _locate_table(self):
        try:
            return self.driver.find_element(By.ID, "historyTable")
        except Exception:
            pass
        for xp in [
            "//filing-history-filings//table",
            "//table[contains(@class,'filing') or contains(@id,'history')]",
            "//div[contains(@class,'table')]//table",
            "//table"
        ]:
            try:
                return self.driver.find_element(By.XPATH, xp)
            except Exception:
                continue
        return None

    def _clean_text(self, el):
        txt = (el.get_attribute("innerText") or el.text or "").strip()
        if not txt:
            txt = (el.get_attribute("textContent") or "").strip()
        return re.sub(r"\s+", " ", txt)

    def _header_cells(self, table):
        heads = table.find_elements(By.CSS_SELECTOR, "thead th")
        if heads:
            return heads
        return table.find_elements(By.XPATH, ".//thead//th | .//thead//td")

    def _resolve_columns(self, table):
        """Map columns by header labels, with inference fallback."""
        self.col_case = self.col_type = self.col_status = None

        # 1) Header-based
        heads = self._header_cells(table)
        for idx, h in enumerate(heads):
            label = self._norm(self._clean_text(h))
            if any(k in label for k in ["case", "case #", "case no", "case number", "filing name", "filing #", "filing no"]):
                if self.col_case is None: self.col_case = idx
            if any(k in label for k in ["filing type", "type"]):
                if self.col_type is None: self.col_type = idx
            if "status" in label and self.col_status is None:
                self.col_status = idx

        # 2) Fallback by sampling content
        rows = table.find_elements(By.CSS_SELECTOR, "tbody tr")
        sample = rows[:min(5, len(rows))]
        pat_case = re.compile(r"\b\d{2,4}-\d{3,7}-[A-Za-z]{1,4}\b")
        pat_digits = re.compile(r"\b\d{8,}\b")

        if sample:
            tds_count = len(sample[0].find_elements(By.CSS_SELECTOR, "td"))
            for j in range(tds_count):
                vals = []
                for r in sample:
                    tds = r.find_elements(By.CSS_SELECTOR, "td")
                    if j >= len(tds): continue
                    # prefer tooltip/title
                    t = (tds[j].get_attribute("title") or "").strip()
                    if t: vals.append(t)
                    spans = tds[j].find_elements(By.XPATH, ".//span[@title]")
                    if spans:
                        t = (spans[0].get_attribute("title") or "").strip()
                        if t: vals.append(t)
                    txt = self._clean_text(tds[j])
                    if txt: vals.append(txt)
                joined = " | ".join(vals)
                n = self._norm(joined)
                if self.col_type is None and (("proposed" in n and "judg" in n) or ("consent" in n and "judg" in n)):
                    self.col_type = j
                if self.col_status is None and any(s in n for s in ["filed", "accepted", "completed", "complete", "rejected"]):
                    self.col_status = j
                if self.col_case is None and (pat_case.search(joined) or pat_digits.search(joined)):
                    self.col_case = j

        print(f"üìë Column map ‚Üí case:{self.col_case} type:{self.col_type} status:{self.col_status}")

    def _cell_best_text(self, td):
        for attr in ["title", "aria-label", "data-original-title", "data-title"]:
            v = td.get_attribute(attr)
            if v and v.strip():
                return v.strip()
        spans = td.find_elements(By.XPATH, ".//span[@title]")
        if spans:
            v = spans[0].get_attribute("title")
            if v and v.strip():
                return v.strip()
        return self._clean_text(td)

    # ---------------------------
    # Target checks
    # ---------------------------
    def _is_target_type(self, filing_text):
        n = self._norm(filing_text)
        return ("consent" in n and "judg" in n) or ("proposed" in n and "judg" in n)

    def _is_target_status(self, status_text):
        n = self._norm(status_text)
        return any(k in n for k in ["filed", "accepted", "rejected", "complete", "completed"])

    def _is_filed(self, status_text):
        return "filed" in self._norm(status_text)

    # ---------------------------
    # Filed flow (same tab) + scrolls only
    # ---------------------------
    def _open_row_details_same_tab(self, row):
        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", row)
        self._sleep(self.t_short)
        self.driver.execute_script("arguments[0].click();", row)
        self._sleep(self.t_long)
        self.wait.until(EC.presence_of_element_located((
            By.XPATH, "//a[@data-toggle='tab' and contains(@href,'#statusTableTab')]"
        )))
        self._sleep(self.t_short)

    def _click_status_updates_and_filed_copy_then_scroll(self):
        print("  üîç Status Updates tab‚Ä¶")
        tab = self.wait.until(EC.element_to_be_clickable((
            By.XPATH, "//a[@data-toggle='tab' and contains(@href,'#statusTableTab')]"
        )))
        self.driver.execute_script("arguments[0].click();", tab)
        self._sleep(self.t_med)

        print("  üì• Click 'Filed Stamped Copy'‚Ä¶")
        btn = self.wait.until(EC.element_to_be_clickable((
            By.XPATH,
            "//button[contains(translate(@title,'FSC','fsc'),'filed stamped copy') or "
            "contains(translate(normalize-space(.),'FSC','fsc'),'filed stamped copy')]"
        )))
        self.driver.execute_script("arguments[0].click();", btn)
        self._sleep(self.t_long)  # allow download to start

        # required: just scroll after clicking
        self.driver.execute_script("window.scrollBy(0, document.body.scrollHeight);")
        self._sleep(self.t_med)

    def _wait_download(self, timeout=120):
        print("  ‚è≥ Waiting download‚Ä¶")
        end = time.time() + timeout
        while time.time() < end:
            pdfs = glob.glob(os.path.join(self.download_path, "*.pdf"))
            partials = glob.glob(os.path.join(self.download_path, "*.crdownload"))
            if pdfs and not partials:
                newest = max(pdfs, key=os.path.getmtime)
                s1 = os.path.getsize(newest); self._sleep(self.t_dlchk)
                s2 = os.path.getsize(newest)
                if s1 == s2:
                    print(f"  ‚úÖ Downloaded: {os.path.basename(newest)}")
                    return newest
            self._sleep(self.t_short)
        print("  ‚ö†Ô∏è Download timeout; using latest if any")
        return max(glob.glob(os.path.join(self.download_path, "*.pdf")), key=os.path.getmtime, default=None)

    def _rename_pdf(self, path, case_number, filing_text):
        if not path or not os.path.exists(path):
            print("  ‚ùå No file to rename"); return False
        fname = f"{self._safe_fragment(case_number)}_{self._canonical_type_for_filename(filing_text)}.pdf"
        newp = os.path.join(self.download_path, fname)
        i = 1
        while os.path.exists(newp):
            newp = os.path.join(self.download_path, f"{self._safe_fragment(case_number)}_{self._canonical_type_for_filename(filing_text)}__{i}.pdf")
            i += 1
        os.rename(path, newp)
        print("  ‚úÖ Renamed ‚Üí", os.path.basename(newp)); self._sleep(self.t_short)
        return True

    def _scroll_back_to_table(self):
        print("  üîΩ Scrolling to filings table‚Ä¶")
        table = self._locate_table()
        if table:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'start'});", table)
        self._sleep(self.t_med)
        self.wait.until(lambda d: len(d.find_elements(By.CSS_SELECTOR, "table tbody tr")) >= 0)
        self._sleep(self.t_short)
        print("  ‚úÖ Ready for next row.")

    # ---------------------------
    # Pagination helpers
    # ---------------------------
    def _first_row_signature(self):
        try:
            try:
                row = self.driver.find_element(By.CSS_SELECTOR, "#historyTable tbody tr")
            except Exception:
                row = self.driver.find_element(By.CSS_SELECTOR, "table tbody tr")
            return row.text.strip()
        except Exception:
            return f"rows:{len(self.driver.find_elements(By.CSS_SELECTOR, 'table tbody tr'))}"

    def _next_page(self):
        print("\nüîÑ Next page‚Ä¶")
        try:
            next_btn = self.wait.until(EC.presence_of_element_located((By.ID, "historyTable_next")))
            classes = (next_btn.get_attribute("class") or "").lower()
            if "disabled" in classes or (next_btn.get_attribute("aria-disabled") or "").lower() == "true":
                print("‚ÑπÔ∏è Last page."); return False
            before = self._first_row_signature()
            self.driver.execute_script("arguments[0].click();", next_btn)
            self._sleep(self.t_long)
            self.wait.until(lambda d: self._first_row_signature() != before)
            self._sleep(self.t_med)
            print("‚úÖ Next page loaded.")
            return True
        except TimeoutException:
            print("‚ùå Next timed out"); return False
        except Exception as e:
            print("‚ùå Next error:", e); return False

    # ---------------------------
    # Main per-page loop
    # ---------------------------
    def process_current_page(self, page_no=1):
        print(f"\nüìÑ Processing page {page_no}")
        print("-" * 50)

        table = self._locate_table()
        if not table:
            print("‚ùå Could not locate the filings table.")
            return

        # Map columns once per page
        self._resolve_columns(table)

        i = 0
        while True:
            rows = table.find_elements(By.CSS_SELECTOR, "tbody tr")
            if i >= len(rows):
                break

            try:
                row = rows[i]
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", row)
                self._sleep(self.t_short)

                # Cells
                tds = row.find_elements(By.CSS_SELECTOR, "td")
                case_val = filing_val = status_val = ""

                if tds:
                    if self.col_case is not None and self.col_case < len(tds):
                        case_val = self._cell_best_text(tds[self.col_case])
                    if self.col_type is not None and self.col_type < len(tds):
                        filing_val = self._cell_best_text(tds[self.col_type])
                    if self.col_status is not None and self.col_status < len(tds):
                        status_val = self._cell_best_text(tds[self.col_status])

                # Fallbacks
                if not case_val:
                    case_val = self._extract_case_fallback(row)

                # Check targets
                if not (filing_val and self._is_target_type(filing_val)):
                    i += 1; self._sleep(self.t_row); continue
                if not (status_val and self._is_target_status(status_val)):
                    i += 1; self._sleep(self.t_row); continue
                if not case_val:
                    i += 1; self._sleep(self.t_row); continue

                filing_csv_label = self._canonical_type_for_csv(filing_val)
                print(f"  ‚ñ∂Ô∏è Row {i+1}: {case_val} | {filing_csv_label} | {status_val}")

                # ALWAYS note in CSV for our target status set
                self._log_csv(case_val, filing_csv_label, status_val)

                # If Filed -> perform download flow
                if self._is_filed(status_val):
                    self._open_row_details_same_tab(row)
                    self._click_status_updates_and_filed_copy_then_scroll()
                    downloaded = self._wait_download()
                    ok = self._rename_pdf(downloaded, case_val, filing_csv_label) if downloaded else False
                    if ok:
                        self.total_downloads += 1
                        print(f"  ‚úÖ Filed copy downloaded for {case_val}")
                    else:
                        print(f"  ‚ùå Download failed for {case_val}")
                    self._scroll_back_to_table()
                    # Rebind table after detail view
                    table = self._locate_table()

                # Next row
                i += 1
                self._sleep(self.t_row)

            except StaleElementReferenceException:
                print(f"  ‚ö†Ô∏è Row {i+1}: stale; retry same index")
                self._sleep(self.t_med)
                table = self._locate_table()
                continue
            except Exception as e:
                print(f"  ‚ö†Ô∏è Row {i+1} error: {e}; skipping")
                i += 1
                self._sleep(self.t_row)

        print("‚úÖ Page complete.")

    def _extract_case_fallback(self, row):
        text = row.text or ""
        m = re.search(r"\b\d{2,4}-\d{3,7}-[A-Za-z]{1,4}\b", text)
        if m: return m.group(0)
        m2 = re.search(r"\b\d{8,}\b", text)
        return m2.group(0) if m2 else ""

    # ---------------------------
    # All pages
    # ---------------------------
    def process_all_pages(self):
        print("\nüöÄ Begin processing all pages‚Ä¶")
        page = 1
        while True:
            print(f"\n{'='*60}\nüìÑ PROCESSING PAGE {page}\n{'='*60}")
            self.process_current_page(page)
            self.processed_pages += 1
            print(f"\nüìä PROGRESS ‚Üí pages: {self.processed_pages} | downloads: {self.total_downloads}")

            self._sleep(self.t_med)
            if self._next_page():
                page += 1
                continue
            print("\nüéâ Completed all pages.")
            break

        print(f"\n{'='*60}\nüéâ FINAL SUMMARY\n{'='*60}")
        print(f"üìÑ Pages processed: {self.processed_pages}")
        print(f"üì• PDFs downloaded: {self.total_downloads}")
        print(f"üìù CSV: {self.spreadsheet_path}")
        print(f"üìÅ Folder: {self.download_path}\n{'='*60}")
        return self.total_downloads

    # ---------------------------
    # Entry point
    # ---------------------------
    def run(self, start_date="07/01/2025", email=None, password=None):
        print("\n" + "="*20 + " STEP 1: LOGIN " + "="*20)
        if not self.login(email=email, password=password):
            print("‚ùå Login failed!"); return
        print("\n" + "="*20 + " STEP 2: DATE & SEARCH " + "="*20)
        if not self.set_date_and_search(start_date=start_date):
            print("‚ö†Ô∏è Search failed"); return
        print("\n" + "="*20 + " STEP 3: PROCESS PAGES " + "="*20)
        self.process_all_pages()
        print("\n" + "="*60 + "\n‚úÖ Automation finished. Browser stays open.\n" + "="*60)


def main():
    print("üèõÔ∏è  Michigan Filing Complete Automation\n" + "=" * 60)
    base = os.path.join(os.getcwd(), "michigan_pdfs")
    os.makedirs(base, exist_ok=True)
    bot = MichiganAutomation(download_path=base)
    # Uses env vars if set; otherwise falls back to provided defaults:
    bot.run(start_date="07/01/2025")
    # Or explicitly:
    # bot.run(start_date="07/01/2025", email="you@example.com", password="secret")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Interrupted; browser remains open.")
    except Exception as e:
        print("\n‚ùå Unexpected error:", e)
